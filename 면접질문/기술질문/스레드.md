## 프로세스와 쓰레드에 대해 설명하고, 둘의 차이를 설명하시오.
Process: 실행 중인 하나의 애플리케이션으로 사용자가 애플리케이션을 실행하면 운영체제로부터 실행에 필요한 메모리를 할당받아 애플리케이션의 코드를 실행하게 된다. 
Thread: 프로세스 내에서 순차적으로 실행되는 실행 흐름의 최소 단위를 말한다. 하나의 프로세스에선 기본 한개의 스레드가 존재하고 그걸 메인스레드라 부른다.

하나의 프로세스에서 오류가 발생해도 다른 프로레스에게 영향을 미치지 않는다.
하지만 Thread는 하나의 프로세스 내부에 생성되기 때문에 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수 있어 다른 스레드에게 영향을 미치게 된다.
<br/><br/>
## 안드로이드에서 Main Thread와 Worker Thread로 구분하는 이유를 설명하시오
Main Thread는 액티비티와 컴포넌트들의 사용을 담당하고 연동하는 역할을 한다. UI 컴포넌트들과 밀접한 연관이 있는 Thread 이다보니 UI Thread라고도 불린다. 
그런데 다른 작업들에 의해 Main Thread가 UI와 동기화되지 못하고 지연되는 경우에는 ANR이 발생할 수 있다.
이러한 문제점을 막기위해 불안정한 UI관련 작업이나 비동기 작업, High Cost의 연산작업 등은 Worker Thread를 따로 만들어 처리하도록 합니다. 
<br/><br/>
## ANR이란? 
Application Not Responding, UI 관련 작업이 일정기간 이상 반응되지 못하면 발생하는 오류이다.
<br/><br/>
## 스레드를 만드는 두가지 방법 
Thread 클래스를 상속하는 방법과 Runnable 인터페이스를 구현하는 방법이 있다.    
<br/><br/>
## Thread와 Runnable 을 통한 스레드 생성의 차이를 설명하시오
기능상 차이는 없다. 하지만 Thread를 상속받으면 기타 다른 클래스를 상속받을 수 없다. 그래서 다른 클래스를 상속해야 하는 경우 또는 Thread 클래스의 run() 메서드만을 사용하는 경우에 Runnable 인터페이스를 구현한다. 
반대로, Thread 클래스에서 run() 메서드 외의 기능을 재정의해야 하거나, 확장이 필요한 경우 Thread 클래스를 상속하여 사용한다. 
<br/><br/>
## Looper와 Handler 에 대해 간략히 설명하시오 
 Looper는 Loop를 실행하고, 메세지 큐로 전달되는 메시지 또는 Runnable 객체가 존재하는지 검사한다. 메시지가 들어오면 차례로 꺼내 해당 메시지를 처리할 적절한 Handler를 호출한다.
Handler는 Looper로부터 받은 Message를 실행, 처리하거나 다른 스레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 스레드 간의 통신 장치이다. 
<br/><br/>
## 스레드 간 통신은 어떻게 동작하는지 설명해주세요 
다른 스레드로부터 메시지나 Runnable 객체가 들어오면 Handler를 통해 Message Queue에 넣는다. 해당 메시지들을 Looper가 꺼내어 해당 메시지를 처리할 적절한 Handler를 호출한다. 
<br/><br/>
## 메시지와 메시지큐에 대한 간략한 설명 
메시지는 스레드 간 통신할 내용을 담는 객체이고, 메시지큐는 이러한 메시지를 큐 형태로 관리하는 자료 구조로 들어온 순서에 따라 메시지를 차례대로 저장하고 처리한다. 
<br/><br/>
## 핸들러를 통해 메시지를 전달하는 방식 말고도 Runnable 객체를 사용하는 방법도 있는데 이의 장점에 대해 설명하시오. 
메시지를 사용한 스레드 통신은 메시지 객체에 값을 채우는 과정과 해당 데이터를 식별하고 처리하는 과정이 번거롭다. 그래서 실행코드가 담긴 객체인 Runnable을 보내, 전달받은 스레드는 해당 객체의 코드를 직접 실행하도록 하여 비교적 간단하게 스레드 간 통신을 수행하게 한다. 
<br/><br/>
## 하나의 핸들러에서 많은 메시지를 처리하는 상황에서 해결책은?
핸들러는 스레드 당 여러개를 만들 수 있기 때문에, 메시지 종류 및 기능에 따라 여러 개의 핸들러로 난워서 처리하는게 더 효율적이다. 
<br/><br/>
## Worker Thread 에서 UI 업데이트를 요청하는 경우 어떻게 처리할 것인가?
핸들러를 사용하거나
runOnUiThread를 사용하여 메인 스레드를 통해 UI를 업데이트한다. 
<br/><br/>
## runOnUiThread에 대해 설명하고 Handler와의 차이에 대해 설명하시오.
Handler는 post 방식을 통해 매번 이벤트를 발생시키지만, runOnUiThread 는 현재 시점이 UI 스레드 (메인 쓰레드) 이면 바로 실행시킨다는 점에서 효율적이다. 
<br/><br/>
## AsyncTask가 무엇이며 어떤 메소드와 파라미터 값들로 동작하는지 설명하시오
AsyncTask 클래스는 한 번에 여러개의 Task가 실행될 수 있는 안드로이드 어플리케이션 환경에서 멀티스레딩을 구현할 수 있는 방법이다. UI 스레드에서 수행한다면 UI 스레드가 차단될 수 있는 작업을 비동기적으로 수행 할 수 있다.
onPreExcuted, doInBackground, onUpdateProgress, onPostExcute 메소드가 있으며, 실행시 Task에 전송될 타입인 params와 백그라운드 동작의 진행상황 타입인 Progress, 백그라운 동작의 결과 타입인 Result를 파라미터로 받는다. 
<br/><br/>
## 백그라운드에서 asynTask를 시작할 수 있나?
asynTask는 메인 스레드에서만 호출하는 것이 필수이며, 만약 그렇지 않다면 onPreExecute, onProgressUpdate, onPostExecuted 함수에서 UI를 터치하면 충돌이 일어날 것이다.
<br/><br/>
## asynTask 클래스를 구현할 때 필수 함수는?
doInBackground 함수를 필수적으로 구현해야 한다. 
<br/><br/>
## 스레드풀에 관해 설명하시오.

스레드 풀은 미리 생성된 스레드들의 집합으로 스레드를 생성하거나 다시 수거할때 드는 비용문제를 해결하기위해 미리 스레드들을 만들고 관리하는 곳이라 생각하면 된다. 
<br/><br/>
## 응용프로그램이 실행을 시작하면 어떤 프로세스의 의해 그 실행이 행해지나?

Zygote 프로세스에 의해 실행되며 해당 zygote 프로세스는 정확히 가상머신의 생성과 새 프로세스 의 시작을 fork 처리 한다.
<br/><br/>
## 그럼 왜 zygote를 사용하는가?

안드로이드앱은 java코드로 작성되어있어 리눅스상에서 native process 로 실행될수 없어 가상머신(구 달빅-신 ATR ) 을 통해 실행된다. 이런 어플리케이션은 각자 독립적인 가상머신위에서 실행되는데 
실행될때마다 자신의 가상머신을 초기화하는데 큰 비용이 발생하게 된다. 그래서 zygote 를 통해 미리 생성된 가상머신을 복제(공유)하여 활용해 비용문제를 해결한다.
두번째 이유는 메모리 공유를 통한 비용감소이다. 
zygote 에 의해 fork 되는 모든앱의 프로세스들은 한 프로세스에 의해 fork 되므로 암묵적으로 커널에서 수행하는 메모리 공유기능을 이용하게 된다. 그래서 보통 안드로이드 앱은 암묵적으로 자신의 메모리 공간의 80~90% 를 다른앱과 공유하므로 메모리 사용량을 극대화 할수있게된다. 예시?를 들면, zygote는 대부분의 앱이 사용하는 core library class와 리소스를 미리 메모리에 로딩하고 이에 대한 연결정보를 구성하여 이를 다른앱에게 공유함으로써 실행시간을 단축시킨다.
<br/><br/>
